import asyncio
import logging
from dataclasses import dataclass
from datetime import datetime
from typing import List, Dict, Optional
from enum import Enum
from abc import ABC, abstractmethod

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class MessageType(Enum):
    """Enum defining different types of messages that can be processed"""
    RANDOM = "random"
    BALANCE = "balance"
    TRANSFER = "transfer"
    HELLO = "hello"
    CRYPTO = "crypto"

@dataclass
class Message:
    """
    Represents a message that can be exchanged between agents.
    
    Attributes:
        type: The type of the message
        content: The actual content/payload of the message
        metadata: Optional metadata associated with the message
        timestamp: When the message was created
    """
    type: MessageType
    content: str
    metadata: Dict = None
    timestamp: datetime = None

    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}
        if self.timestamp is None:
            self.timestamp = datetime.now()

class MessageBus:
    """
    Thread-safe message bus implementation using asyncio.Queue
    """
    def __init__(self):
        self._queue = asyncio.Queue()
        
    async def publish(self, message: Message) -> None:
        """Publish a message to the bus"""
        await self._queue.put(message)
        
    async def consume(self) -> Message:
        """Consume a message from the bus"""
        return await self._queue.get()
    
    def is_empty(self) -> bool:
        """Check if the bus is empty"""
        return self._queue.empty()

class Behavior(ABC):
    """
    Abstract base class for implementing proactive behaviors.
    
    Behaviors represent periodic actions that agents perform regardless
    of incoming messages.
    """
    def __init__(self, interval: float):
        self.interval = interval
        self.last_execution = datetime.now()
        
    @abstractmethod
    async def execute(self) -> List[Message]:
        """
        Execute the behavior and return any resulting messages.
        
        Returns:
            List of messages generated by this behavior
        """
        pass

class MessageHandler(ABC):
    """
    Abstract base class for implementing reactive message handlers.
    
    Handlers process incoming messages and optionally generate response messages.
    """
    @abstractmethod
    async def can_handle(self, message: Message) -> bool:
        """
        Check if this handler can process the given message.
        
        Args:
            message: The message to check
        
        Returns:
            True if this handler can process the message, False otherwise
        """
        pass
    
    @abstractmethod
    async def handle(self, message: Message) -> List[Message]:
        """
        Process a message and generate any response messages.
        
        Args:
            message: The message to process
        
        Returns:
            List of response messages
        """
        pass

class Agent:
    """
    Generic autonomous agent implementation.
    
    The agent processes incoming messages using registered handlers and
    executes periodic behaviors.
    """
    def __init__(self, name: str):
        self.name = name
        self.inbox = MessageBus()
        self.outbox = MessageBus()
        self.handlers: List[MessageHandler] = []
        self.behaviors: List[Behavior] = []
        self._running = False
        
    def register_handler(self, handler: MessageHandler) -> None:
        """Register a message handler"""
        self.handlers.append(handler)
        
    def register_behavior(self, behavior: Behavior) -> None:
        """Register a periodic behavior"""
        self.behaviors.append(behavior)
        
    async def process_message(self, message: Message) -> None:
        """
        Process an incoming message using registered handlers.
        
        Args:
            message: The message to process
        """
        for handler in self.handlers:
            try:
                if await handler.can_handle(message):
                    responses = await handler.handle(message)
                    for response in responses:
                        await self.outbox.publish(response)
            except Exception as e:
                logger.error(f"Error processing message {message} with handler {handler}: {e}")
                
    async def execute_behaviors(self) -> None:
        """Execute all registered behaviors if their interval has elapsed"""
        current_time = datetime.now()
        for behavior in self.behaviors:
            try:
                if (current_time - behavior.last_execution).total_seconds() >= behavior.interval:
                    messages = await behavior.execute()
                    behavior.last_execution = current_time
                    for message in messages:
                        await self.outbox.publish(message)
            except Exception as e:
                logger.error(f"Error executing behavior {behavior}: {e}")
                
    async def run(self) -> None:
        """Main agent loop"""
        self._running = True
        logger.info(f"Agent {self.name} starting...")
        
        try:
            while self._running:
                # Process messages in inbox
                if not self.inbox.is_empty():
                    message = await self.inbox.consume()
                    await self.process_message(message)
                
                # Execute behaviors
                await self.execute_behaviors()
                
                # Small delay to prevent CPU hogging
                await asyncio.sleep(0.1)
        except Exception as e:
            logger.error(f"Error in agent {self.name} main loop: {e}")
        finally:
            logger.info(f"Agent {self.name} stopping...")
            
    def stop(self) -> None:
        """Stop the agent"""
        self._running = False
